[
  {
    "objectID": "reference/utils.polyharmonic.html",
    "href": "reference/utils.polyharmonic.html",
    "title": "utils.polyharmonic",
    "section": "",
    "text": "utils.polyharmonic\nutils.polyharmonic(x, center, a=1)\nPolyharmonic Spline RBF"
  },
  {
    "objectID": "reference/operators.cartesian_gradient.html",
    "href": "reference/operators.cartesian_gradient.html",
    "title": "operators.cartesian_gradient",
    "section": "",
    "text": "operators.cartesian_gradient\noperators.cartesian_gradient(node_id, field, cloud, clip_val=None)\nComputes the gradient of the field (given by its values) at a specific node of a cartesian grid, using finite differences\nArgs: node_id (int): The node at which to conmpute the gradient value field (Float[Array, ‚Äúnb_grid_points‚Äù]): The field to use for the gradient computation cloud (Cloud): The cloud of points to use: must be a square grid clip_val (float, optional): The limit to which to clip the value to avoid blowup. Defaults to None.\nReturns: Float[Array, ‚Äúdim‚Äù]: The gradient of the field at x"
  },
  {
    "objectID": "reference/cloud.GmshCloud.html",
    "href": "reference/cloud.GmshCloud.html",
    "title": "cloud.GmshCloud",
    "section": "",
    "text": "cloud.GmshCloud(self, filename, mesh_save_location=None, **kwargs)\nA class to store the cloud of points issued from GMSH and related properties\n\n\n\n\n\nName\nDescription\n\n\n\n\ndefine_outward_normals\nCalculates (approximate) outward normal vectors to nodes on the boundaries.\n\n\nextract_nodes_and_boundary_type\nExtract nodes and boundary types from a .msh file according to Gmsh format 4.0.8\n\n\nget_meshfile\nGets the definitive mesh file to work with\n\n\n\n\n\ncloud.GmshCloud.define_outward_normals()\nCalculates (approximate) outward normal vectors to nodes on the boundaries. Raises: AssertionError: When the mesh is not fine enough to compute normals\n\n\n\ncloud.GmshCloud.extract_nodes_and_boundary_type()\nExtract nodes and boundary types from a .msh file according to Gmsh format 4.0.8\n\n\n\ncloud.GmshCloud.get_meshfile(filename, mesh_save_location)\nGets the definitive mesh file to work with\nArgs: filename (str): see init() mesh_save_location (str): see init(). If None, the mesh is saved in the same directory as the filename"
  },
  {
    "objectID": "reference/cloud.GmshCloud.html#methods",
    "href": "reference/cloud.GmshCloud.html#methods",
    "title": "cloud.GmshCloud",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndefine_outward_normals\nCalculates (approximate) outward normal vectors to nodes on the boundaries.\n\n\nextract_nodes_and_boundary_type\nExtract nodes and boundary types from a .msh file according to Gmsh format 4.0.8\n\n\nget_meshfile\nGets the definitive mesh file to work with\n\n\n\n\n\ncloud.GmshCloud.define_outward_normals()\nCalculates (approximate) outward normal vectors to nodes on the boundaries. Raises: AssertionError: When the mesh is not fine enough to compute normals\n\n\n\ncloud.GmshCloud.extract_nodes_and_boundary_type()\nExtract nodes and boundary types from a .msh file according to Gmsh format 4.0.8\n\n\n\ncloud.GmshCloud.get_meshfile(filename, mesh_save_location)\nGets the definitive mesh file to work with\nArgs: filename (str): see init() mesh_save_location (str): see init(). If None, the mesh is saved in the same directory as the filename"
  },
  {
    "objectID": "reference/operators.pde_solver_jit.html",
    "href": "reference/operators.pde_solver_jit.html",
    "title": "operators.pde_solver_jit",
    "section": "",
    "text": "operators.pde_solver_jit\noperators.pde_solver_jit(diff_operator, rhs_operator, cloud, boundary_conditions, rbf, max_degree, diff_args=None, rhs_args=None)\nPDE solver just-in-time compiled with respect to the boundary conditions\nArgs: diff_operator (callable): The differential operator (the left-hand side of the PDE), evaluated at each internal point with respect to each RBF centroid seperately, i.e.¬†nodal evaluation. rhs_operator (callable): The right-hand-side operator, evaluated at each node with respect to all centroids at once, i.e.¬†global evaluation. cloud (Cloud): The cloud on which to solve the PDE boundary_conditions (dict): The boundary conditions to enforce, one for each facet given by either a function or an approiate vector rbf (callable): The radial basis function to use max_degree (int): The maximum degree of the polynomial to use in the RBF diff_args (list, optional): The arguments to pass to the differential operator. Defaults to None. rhs_args (list, optional): The arguments to pass to the right-hand-side operator. Defaults to None.\nReturns: SteadySol: A named tuple containing the values and coefficients of the solution, as well as the matrix used in the linear solve"
  },
  {
    "objectID": "reference/operators.pde_multi_solver.html",
    "href": "reference/operators.pde_multi_solver.html",
    "title": "operators.pde_multi_solver",
    "section": "",
    "text": "operators.pde_multi_solver\noperators.pde_multi_solver(diff_operators, rhs_operators, cloud, boundary_conditions, rbf, max_degree, nb_iters=10, tol=1e-06, diff_args=None, rhs_args=None)\nSolves a system of (non-linear) PDEs using an iterative approach for radial basis functions (see pde_solver for details on scalar PDEs)\nArgs: diff_operators (list[callable]): The (nodal) differential operators (the left-hand side of the PDEs) rhs_operator (list[callable]): The (global) right-hand-side operator cloud (Cloud): The same cloud on which to solve the PDEs boundary_conditionss (list[dict]): The boundary conditions to enforce, one for each PDE rbf (callable): The radial basis function to use max_degree (int): The maximum degree of the polynomial to use in the RBF nb_iters (int, optional): The maximum number of iterations to use in the solver. Defaults to 10. tol (float, optional): The tolerance to check for convergence. Defaults to 1e-6. (Currently not used, because of JIT-issues) diff_args (list[list], optional): The arguments to pass to each differential operator. Defaults to list of Nones. rhs_args (list[list], optional): The arguments to pass to each right-hand-side operator. Defaults to list of None.\nRaises: AssertionError: The number of differential operators must match the number of right-hand side operators\nReturns: list[SteadySol]: A list of named named tuples containing the solutions for each PDE"
  },
  {
    "objectID": "reference/operators.divergence.html",
    "href": "reference/operators.divergence.html",
    "title": "operators.divergence",
    "section": "",
    "text": "operators.divergence\noperators.divergence(x, field, centers, rbf=None, clip_val=None)\nComputes the divergence of the vector field (given by its coefficients) at position x\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The position at which to compute the divergence value centers (Float[Array, ‚Äúnb_centers, dim‚Äù]): The centroids of the RBF to use rbf (callable): The rbf to use. (Currently mandadatory, despite the signature.) clip_val (float, optional): The limit to which to clip the value to avoid blowup. Defaults to None.\nReturns: float: The divergence of field at x"
  },
  {
    "objectID": "reference/assembly.core_compute_coefficients.html",
    "href": "reference/assembly.core_compute_coefficients.html",
    "title": "assembly.core_compute_coefficients",
    "section": "",
    "text": "assembly.core_compute_coefficients\nassembly.core_compute_coefficients(field, cloud, rbf, nb_monomials)\nFind nodal and polynomial coefficients for scalar field directly from the number of monomials"
  },
  {
    "objectID": "reference/utils.make_nodal_rbf.html",
    "href": "reference/utils.make_nodal_rbf.html",
    "title": "utils.make_nodal_rbf",
    "section": "",
    "text": "utils.make_nodal_rbf\nutils.make_nodal_rbf(x, node, rbf)\nA function that returns the value of the RBF at a given point x, with respect to a given node. The RBF is tuned to the given node.\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The point at which the RBF is to be evaluated. node (Float[Array, ‚Äúdim‚Äù]): The centroid with respect to which the RBF is evaluated. rbf (Callable): The RBF function to be used, with signature rbf(r) where r is the Euclidean distance between the two points\nReturns: float: The scalar value of the RBF at the given point x, with respect to the given node."
  },
  {
    "objectID": "reference/operators.boundary_conditions_func_to_arr.html",
    "href": "reference/operators.boundary_conditions_func_to_arr.html",
    "title": "operators.boundary_conditions_func_to_arr",
    "section": "",
    "text": "operators.boundary_conditions_func_to_arr\noperators.boundary_conditions_func_to_arr(boundary_conditions, cloud)\nConvert the given boundary conditions from functions to an array"
  },
  {
    "objectID": "reference/operators.enforce_cartesian_gradient_neumann.html",
    "href": "reference/operators.enforce_cartesian_gradient_neumann.html",
    "title": "operators.enforce_cartesian_gradient_neumann",
    "section": "",
    "text": "operators.enforce_cartesian_gradient_neumann\noperators.enforce_cartesian_gradient_neumann(field, grads, boundary_conditions, cloud, clip_val=None)\nSets the gradient at every neumann node using catesian grid"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Functions to help build other functions in the package.\n\n\n\nutils.distance\nEuclidean distance between two points.\n\n\nutils.multiquadric\nHardy‚Äôs Multiquadric RBF\n\n\nutils.gaussian\nGaussian RBF\n\n\nutils.inverse_multiquadric\nInverse Multiquadric RBF\n\n\nutils.polyharmonic\nPolyharmonic Spline RBF\n\n\nutils.thin_plate\nThin Plate Spline RBF\n\n\nutils.make_nodal_rbf\nA function that returns the value of the RBF at a given point x, with respect to a given node. The RBF is tuned to the given node.\n\n\nutils.make_monomial\nA function that returns the value of a monomial at a given point x.\n\n\nutils.make_all_monomials\nA function that returns up to a certain number of monomials\n\n\nutils.compute_nb_monomials\nComputes the number of monomials of dregree less than ‚Äòmax_degree‚Äô, in dimension ‚Äòproblem_dimension‚Äô\n\n\nutils.plot\nWrapper function for matplotlib and seaborn\n\n\nutils.RK4\nNumerical integration with RK4 and fixed-time stepping, but with fine subdivisions of the evaluation time intervals\n\n\n\n\n\n\nFunctions related to building the cloud of points\n\n\n\ncloud.Cloud\nA class to store the meshfree cloud of points and related properties\n\n\ncloud.SquareCloud\nA class to store a cloud of (scattered or regular) points on a unit square\n\n\ncloud.GmshCloud\nA class to store the cloud of points issued from GMSH and related properties\n\n\n\n\n\n\nFunctions related to assembling the matrices needed for the PDE solve\n\n\n\nassembly.assemble_Phi\nAssemble the collocation matrix Phi (see equation 5) from Shahane et al.\n\n\nassembly.assemble_P\nAssemble the polynomial matrix P (see equation 6 from Shahane et al.)\n\n\nassembly.assemble_A\nAssemble the matrix A (see equation 4 from Shahane et al.)\n\n\nassembly.assemble_invert_A\nAssembles the inverts of the matrix A\n\n\nassembly.assemble_op_Phi_P\nAssembles op(Phi) and op(P), the collocation and polynomial matrices after a differential operator is applied to internal nodes\n\n\nassembly.assemble_bd_Phi_P\nAssembles bd(Phi) and bd(P), the collocation and polynomial matrices after boundary conditions are applied to boundary nodes\n\n\nassembly.assemble_B\nAssemble matrix B using opPhi, bdPhi, opP, bdP, and A, see equation (*) from Shahane et al.\n\n\nassembly.assemble_q\nAssemble the right hand side q using the given operator (See equation * from Shahane et al.)\n\n\nassembly.core_compute_coefficients\nFind nodal and polynomial coefficients for scalar field directly from the number of monomials\n\n\nassembly.compute_coefficients\nFind nodal and polynomial coefficients for scalar field\n\n\nassembly.get_field_coefficients\nFind nodal and polynomial coefficients for scalar field. Alias of compute_coefficients()\n\n\n\n\n\n\nFunctions related to the operators used in the PDE solve\n\n\n\noperators.nodal_value\nComputes the rbf or polynomial value at position x\n\n\noperators.nodal_gradient\nComputes the gradient of the rbf or polynomial at position x\n\n\noperators.nodal_laplacian\nComputes the laplacian as the trace of the jacobian of the gradient of the rbf or polynomial at position x\n\n\noperators.nodal_div_grad\nComputes the laplacian as the divergence of the gradient of the rbf or polynomial at position x\n\n\noperators.value\nComputes the value of the field (given by its coefficients) at position x\n\n\noperators.gradient\nComputes the gradient of the field (given by its coefficients) at position x\n\n\noperators.gradient_vals\nComputes the gradient of the field (given by its values) at position x\n\n\noperators.cartesian_gradient\nComputes the gradient of the field (given by its values) at a specific node of a cartesian grid, using finite differences\n\n\noperators.divergence\nComputes the divergence of the vector field (given by its coefficients) at position x\n\n\noperators.laplacian\nComputes the laplacian of the field (given by its coefficients) at position x\n\n\noperators.laplacian_vals\nComputes the laplacian of the field (given by its values) at position x\n\n\noperators.integrate_field\nIntegrate the field (given by its coefficients) over the 2D square cloud domain, using the midpoint rule:\n\n\noperators.interpolate_field\nInterpolates field from cloud1 to cloud2 given that their nodes might be numbered differently\n\n\noperators.pde_solver\nSolves a PDE using radial basis functions\n\n\noperators.pde_solver_jit\nPDE solver just-in-time compiled with respect to the boundary conditions\n\n\noperators.pde_multi_solver\nSolves a system of (non-linear) PDEs using an iterative approach for radial basis functions (see pde_solver for details on scalar PDEs)\n\n\noperators.enforce_cartesian_gradient_neumann\nSets the gradient at every neumann node using catesian grid\n\n\noperators.duplicate_robin_coeffs\nDuplicate the Robin coefficients to the nodes of the facets they are applied to\n\n\noperators.apply_neumann_conditions\nEnforces the Neumann boundary conditions to the field\n\n\noperators.zerofy_periodic_cond\nZero out the periodic boundary conditions (this is aplied before the PDE solve, to overwrite any value set by the user)\n\n\noperators.boundary_conditions_func_to_arr\nConvert the given boundary conditions from functions to an array"
  },
  {
    "objectID": "reference/index.html#utility-functions",
    "href": "reference/index.html#utility-functions",
    "title": "Function reference",
    "section": "",
    "text": "Functions to help build other functions in the package.\n\n\n\nutils.distance\nEuclidean distance between two points.\n\n\nutils.multiquadric\nHardy‚Äôs Multiquadric RBF\n\n\nutils.gaussian\nGaussian RBF\n\n\nutils.inverse_multiquadric\nInverse Multiquadric RBF\n\n\nutils.polyharmonic\nPolyharmonic Spline RBF\n\n\nutils.thin_plate\nThin Plate Spline RBF\n\n\nutils.make_nodal_rbf\nA function that returns the value of the RBF at a given point x, with respect to a given node. The RBF is tuned to the given node.\n\n\nutils.make_monomial\nA function that returns the value of a monomial at a given point x.\n\n\nutils.make_all_monomials\nA function that returns up to a certain number of monomials\n\n\nutils.compute_nb_monomials\nComputes the number of monomials of dregree less than ‚Äòmax_degree‚Äô, in dimension ‚Äòproblem_dimension‚Äô\n\n\nutils.plot\nWrapper function for matplotlib and seaborn\n\n\nutils.RK4\nNumerical integration with RK4 and fixed-time stepping, but with fine subdivisions of the evaluation time intervals"
  },
  {
    "objectID": "reference/index.html#cloud-module",
    "href": "reference/index.html#cloud-module",
    "title": "Function reference",
    "section": "",
    "text": "Functions related to building the cloud of points\n\n\n\ncloud.Cloud\nA class to store the meshfree cloud of points and related properties\n\n\ncloud.SquareCloud\nA class to store a cloud of (scattered or regular) points on a unit square\n\n\ncloud.GmshCloud\nA class to store the cloud of points issued from GMSH and related properties"
  },
  {
    "objectID": "reference/index.html#assembly-module",
    "href": "reference/index.html#assembly-module",
    "title": "Function reference",
    "section": "",
    "text": "Functions related to assembling the matrices needed for the PDE solve\n\n\n\nassembly.assemble_Phi\nAssemble the collocation matrix Phi (see equation 5) from Shahane et al.\n\n\nassembly.assemble_P\nAssemble the polynomial matrix P (see equation 6 from Shahane et al.)\n\n\nassembly.assemble_A\nAssemble the matrix A (see equation 4 from Shahane et al.)\n\n\nassembly.assemble_invert_A\nAssembles the inverts of the matrix A\n\n\nassembly.assemble_op_Phi_P\nAssembles op(Phi) and op(P), the collocation and polynomial matrices after a differential operator is applied to internal nodes\n\n\nassembly.assemble_bd_Phi_P\nAssembles bd(Phi) and bd(P), the collocation and polynomial matrices after boundary conditions are applied to boundary nodes\n\n\nassembly.assemble_B\nAssemble matrix B using opPhi, bdPhi, opP, bdP, and A, see equation (*) from Shahane et al.\n\n\nassembly.assemble_q\nAssemble the right hand side q using the given operator (See equation * from Shahane et al.)\n\n\nassembly.core_compute_coefficients\nFind nodal and polynomial coefficients for scalar field directly from the number of monomials\n\n\nassembly.compute_coefficients\nFind nodal and polynomial coefficients for scalar field\n\n\nassembly.get_field_coefficients\nFind nodal and polynomial coefficients for scalar field. Alias of compute_coefficients()"
  },
  {
    "objectID": "reference/index.html#operators-module",
    "href": "reference/index.html#operators-module",
    "title": "Function reference",
    "section": "",
    "text": "Functions related to the operators used in the PDE solve\n\n\n\noperators.nodal_value\nComputes the rbf or polynomial value at position x\n\n\noperators.nodal_gradient\nComputes the gradient of the rbf or polynomial at position x\n\n\noperators.nodal_laplacian\nComputes the laplacian as the trace of the jacobian of the gradient of the rbf or polynomial at position x\n\n\noperators.nodal_div_grad\nComputes the laplacian as the divergence of the gradient of the rbf or polynomial at position x\n\n\noperators.value\nComputes the value of the field (given by its coefficients) at position x\n\n\noperators.gradient\nComputes the gradient of the field (given by its coefficients) at position x\n\n\noperators.gradient_vals\nComputes the gradient of the field (given by its values) at position x\n\n\noperators.cartesian_gradient\nComputes the gradient of the field (given by its values) at a specific node of a cartesian grid, using finite differences\n\n\noperators.divergence\nComputes the divergence of the vector field (given by its coefficients) at position x\n\n\noperators.laplacian\nComputes the laplacian of the field (given by its coefficients) at position x\n\n\noperators.laplacian_vals\nComputes the laplacian of the field (given by its values) at position x\n\n\noperators.integrate_field\nIntegrate the field (given by its coefficients) over the 2D square cloud domain, using the midpoint rule:\n\n\noperators.interpolate_field\nInterpolates field from cloud1 to cloud2 given that their nodes might be numbered differently\n\n\noperators.pde_solver\nSolves a PDE using radial basis functions\n\n\noperators.pde_solver_jit\nPDE solver just-in-time compiled with respect to the boundary conditions\n\n\noperators.pde_multi_solver\nSolves a system of (non-linear) PDEs using an iterative approach for radial basis functions (see pde_solver for details on scalar PDEs)\n\n\noperators.enforce_cartesian_gradient_neumann\nSets the gradient at every neumann node using catesian grid\n\n\noperators.duplicate_robin_coeffs\nDuplicate the Robin coefficients to the nodes of the facets they are applied to\n\n\noperators.apply_neumann_conditions\nEnforces the Neumann boundary conditions to the field\n\n\noperators.zerofy_periodic_cond\nZero out the periodic boundary conditions (this is aplied before the PDE solve, to overwrite any value set by the user)\n\n\noperators.boundary_conditions_func_to_arr\nConvert the given boundary conditions from functions to an array"
  },
  {
    "objectID": "reference/operators.nodal_value.html",
    "href": "reference/operators.nodal_value.html",
    "title": "operators.nodal_value",
    "section": "",
    "text": "operators.nodal_value\noperators.nodal_value(x, center=None, rbf=None, monomial=None)\nComputes the rbf or polynomial value at position x\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The position at which to evaluate the rbf or polynomial center (Float[Array, ‚Äúdim‚Äù]): The centroid of the RBF if used. (Currently mandadatory, despite the signature.) rbf (callable): The rbf to use. (Currently mandadatory, despite the signature.) monomial (callable): The monomial to use. (Currently mandadatory, despite the signature.)\nReturns: float: The value of the rbf or polynomial at x"
  },
  {
    "objectID": "reference/operators.laplacian.html",
    "href": "reference/operators.laplacian.html",
    "title": "operators.laplacian",
    "section": "",
    "text": "operators.laplacian\noperators.laplacian(x, field, centers, rbf=None, clip_val=None)\nComputes the laplacian of the field (given by its coefficients) at position x\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The position at which to compute the laplacian value centers (Float[Array, ‚Äúnb_centers, dim‚Äù]): The centroids of the RBF to use rbf (callable): The rbf to use. (Currently mandadatory, despite the signature.) clip_val (float, optional): The limit to which to clip the value to avoid blowup. Defaults to None.\nReturns: float: The laplacian of field at x"
  },
  {
    "objectID": "reference/operators.laplacian_vals.html",
    "href": "reference/operators.laplacian_vals.html",
    "title": "operators.laplacian_vals",
    "section": "",
    "text": "operators.laplacian_vals\noperators.laplacian_vals(x, field, cloud, rbf, max_degree)\nComputes the laplacian of the field (given by its values) at position x\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The position at which to compute the laplacian value centers (Float[Array, ‚Äúnb_centers, dim‚Äù]): The centroids of the RBF to use rbf (callable): The rbf to use. (Currently mandadatory, despite the signature.)\nReturns: float: The laplacian of field at x"
  },
  {
    "objectID": "reference/assembly.assemble_invert_A.html",
    "href": "reference/assembly.assemble_invert_A.html",
    "title": "assembly.assemble_invert_A",
    "section": "",
    "text": "assembly.assemble_invert_A\nassembly.assemble_invert_A(cloud, rbf, nb_monomials)\nAssembles the inverts of the matrix A"
  },
  {
    "objectID": "reference/utils.multiquadric.html",
    "href": "reference/utils.multiquadric.html",
    "title": "utils.multiquadric",
    "section": "",
    "text": "utils.multiquadric\nutils.multiquadric(x, center, eps=1.0)\nHardy‚Äôs Multiquadric RBF"
  },
  {
    "objectID": "reference/operators.gradient_vals.html",
    "href": "reference/operators.gradient_vals.html",
    "title": "operators.gradient_vals",
    "section": "",
    "text": "operators.gradient_vals\noperators.gradient_vals(x, field, cloud, rbf, max_degree)\nComputes the gradient of the field (given by its values) at position x\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The position at which to conmpute the gradient value centers (Float[Array, ‚Äúnb_centers, dim‚Äù]): The centroids of the RBF to use rbf (callable): The rbf to use. (Currently mandadatory, despite the signature.) clip_val (float, optional): The limit to which to clip the value to avoid blowup. Defaults to None.\nReturns: Float[Array, ‚Äúdim‚Äù]: The gradient of the field at x"
  },
  {
    "objectID": "reference/operators.interpolate_field.html",
    "href": "reference/operators.interpolate_field.html",
    "title": "operators.interpolate_field",
    "section": "",
    "text": "operators.interpolate_field\noperators.interpolate_field(field, cloud1, cloud2)\nInterpolates field from cloud1 to cloud2 given that their nodes might be numbered differently\nArgs: field (Float[Array, ‚Äúdim‚Äù]): The field to interpolate cloud1 (Cloud): The cloud from which to interpolate cloud2 (Cloud): The cloud to which to interpolate. Must be same type as cloud1, but with different numbering of node, i.e.¬†different boundary conditions\nRaises: AssertionError: The two clouds do not contain the same number of nodes\nReturns: Float[Array, ‚Äúdim‚Äù]: The interpolated field"
  },
  {
    "objectID": "reference/assembly.assemble_q.html",
    "href": "reference/assembly.assemble_q.html",
    "title": "assembly.assemble_q",
    "section": "",
    "text": "assembly.assemble_q\nassembly.assemble_q(operator, boundary_conditions, cloud, rbf, nb_monomials, rhs_args)\nAssemble the right hand side q using the given operator (See equation * from Shahane et al.)\nArgs: operator (callable): the rhs operator to apply boundary_conditions (dict): the boundary conditions to use cloud (Cloud): the cloud of points to use rbf (callable): the radial basis function to use nb_monomials (int): the number of monomials to use rhs_args (list): the fields to use in the application of the operator. Can be either the field values themselves or their coefficients\nReturns: Float[Array, ‚Äúnb_nodes‚Äù]: The vector q"
  },
  {
    "objectID": "reference/cloud.Cloud.html",
    "href": "reference/cloud.Cloud.html",
    "title": "cloud.Cloud",
    "section": "",
    "text": "cloud.Cloud(self, facet_types, support_size='max')\nA class to store the meshfree cloud of points and related properties\n\n\n\n\n\nName\nDescription\n\n\n\n\naverage_spacing\nComputes the average distance between nodes in the cloud\n\n\ndefine_local_supports\nFinds the ‚Äòsupport_size‚Äô nearest neighbords of each node. This function is aware of the renumbering of nodes and uses the renumbering map to renumber the local supports accordingly.\n\n\nprint_global_indices\nPrint the global ids of the cloud of points.\n\n\nrenumber_nodes\nPlaces the internal nodes at the top of the list, then the dirichlet, then neumann, then robin, then periodic nodes.\n\n\nsort_dict_by_keys\nSorts a dictionnay whose values are jax arrays; and returns an array easily indexable\n\n\n\n\n\ncloud.Cloud.average_spacing()\nComputes the average distance between nodes in the cloud\nReturns: float: the mean distance between nodes\n\n\n\ncloud.Cloud.define_local_supports()\nFinds the ‚Äòsupport_size‚Äô nearest neighbords of each node. This function is aware of the renumbering of nodes and uses the renumbering map to renumber the local supports accordingly.\nRaises: AssertionError: When the support size not between 1 (included) and N-1 (included)\nReturns: None: creates aditional attribute ‚Äòlocal_supports‚Äô in the class\n\n\n\ncloud.Cloud.print_global_indices()\nPrint the global ids of the cloud of points.\n:return: A 2d array of the global indices\n\n\n\ncloud.Cloud.renumber_nodes()\nPlaces the internal nodes at the top of the list, then the dirichlet, then neumann, then robin, then periodic nodes.\nRaises: ValueError: When an unknown node type is found\nReturns: None: creates additional attributes like: ‚Äòfacet_nodes‚Äô, ‚Äòrenumbering_map‚Äô in the class. Also renumnbers the local supports, the outward normals, and the global indices\n\n\n\ncloud.Cloud.sort_dict_by_keys(dictionnary)\nSorts a dictionnay whose values are jax arrays; and returns an array easily indexable"
  },
  {
    "objectID": "reference/cloud.Cloud.html#methods",
    "href": "reference/cloud.Cloud.html#methods",
    "title": "cloud.Cloud",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\naverage_spacing\nComputes the average distance between nodes in the cloud\n\n\ndefine_local_supports\nFinds the ‚Äòsupport_size‚Äô nearest neighbords of each node. This function is aware of the renumbering of nodes and uses the renumbering map to renumber the local supports accordingly.\n\n\nprint_global_indices\nPrint the global ids of the cloud of points.\n\n\nrenumber_nodes\nPlaces the internal nodes at the top of the list, then the dirichlet, then neumann, then robin, then periodic nodes.\n\n\nsort_dict_by_keys\nSorts a dictionnay whose values are jax arrays; and returns an array easily indexable\n\n\n\n\n\ncloud.Cloud.average_spacing()\nComputes the average distance between nodes in the cloud\nReturns: float: the mean distance between nodes\n\n\n\ncloud.Cloud.define_local_supports()\nFinds the ‚Äòsupport_size‚Äô nearest neighbords of each node. This function is aware of the renumbering of nodes and uses the renumbering map to renumber the local supports accordingly.\nRaises: AssertionError: When the support size not between 1 (included) and N-1 (included)\nReturns: None: creates aditional attribute ‚Äòlocal_supports‚Äô in the class\n\n\n\ncloud.Cloud.print_global_indices()\nPrint the global ids of the cloud of points.\n:return: A 2d array of the global indices\n\n\n\ncloud.Cloud.renumber_nodes()\nPlaces the internal nodes at the top of the list, then the dirichlet, then neumann, then robin, then periodic nodes.\nRaises: ValueError: When an unknown node type is found\nReturns: None: creates additional attributes like: ‚Äòfacet_nodes‚Äô, ‚Äòrenumbering_map‚Äô in the class. Also renumnbers the local supports, the outward normals, and the global indices\n\n\n\ncloud.Cloud.sort_dict_by_keys(dictionnary)\nSorts a dictionnay whose values are jax arrays; and returns an array easily indexable"
  },
  {
    "objectID": "reference/utils.inverse_multiquadric.html",
    "href": "reference/utils.inverse_multiquadric.html",
    "title": "utils.inverse_multiquadric",
    "section": "",
    "text": "utils.inverse_multiquadric\nutils.inverse_multiquadric(x, center, eps=1.0)\nInverse Multiquadric RBF"
  },
  {
    "objectID": "reference/assembly.assemble_A.html",
    "href": "reference/assembly.assemble_A.html",
    "title": "assembly.assemble_A",
    "section": "",
    "text": "assembly.assemble_A\nassembly.assemble_A(cloud, rbf, nb_monomials=2)\nAssemble the matrix A (see equation 4 from Shahane et al.)\nArgs: cloud (Cloud): The cloud of points to use, along with all required information rbf (callable, optional): The radial basis function to use nb_monomials (int): The number of monomials to use, with increasing degree. Defaults to 2.\nReturns: Float[Array, ‚Äúnb_nodes+nb_monomials, nb_nodes+nb_monomials‚Äù]: The matrix A"
  },
  {
    "objectID": "reference/assembly.assemble_Phi.html",
    "href": "reference/assembly.assemble_Phi.html",
    "title": "assembly.assemble_Phi",
    "section": "",
    "text": "assembly.assemble_Phi\nassembly.assemble_Phi(cloud, rbf)\nAssemble the collocation matrix Phi (see equation 5) from Shahane et al.\nArgs: cloud (Cloud): The points to use, along with all required information rbf (callable, optional): The radial basis function to use\nReturns: Float[Array, ‚Äúnb_nodes, nb_nodes‚Äù]: The collocation matrix Phi"
  },
  {
    "objectID": "reference/operators.integrate_field.html",
    "href": "reference/operators.integrate_field.html",
    "title": "operators.integrate_field",
    "section": "",
    "text": "operators.integrate_field\noperators.integrate_field(field, cloud, rbf, max_degree)\nIntegrate the field (given by its coefficients) over the 2D square cloud domain, using the midpoint rule: 1. Identify the small squares in the domain (all identical) 2. Get the field value at the center of each square 3. Account for border and corner values: https://stackoverflow.com/a/62991037/8140182 4. Compute the approximate integral\nReturns: float: the integral of the field over the domain"
  },
  {
    "objectID": "assets/README_PyPI.html",
    "href": "assets/README_PyPI.html",
    "title": "ùïåpdes",
    "section": "",
    "text": "ùïåpdes is a general-purpose library for mesh-free PDE simulation and control. - GitHub project: https://github.com/ddrous/Updes - Documentation: https://ddrous.github.io/Updes/\n\n\nùïåpdes leverages Radial Basis Functions (RBFs) and JAX to provide the following features: - User-centric design: no need to re-implement a solver for each new PDE - Lightning fast mesh-free simulation via Radial Basis Functions - Robust differentiable simulation via JAX, and portable across CPU, GPU, and TPU - Support for Dirichlet, Neumann, Robin, and Periodic boundary conditions - Automatic generation of normals from 2D GMSH meshes\nùïåpdes in incredibly extendable, with additional features added frequently.\n\n\n\nThe package is available on PyPI. You can install it with\npip install updes\nThe example below illustrates how to solve the Laplace equation with Dirichlet and Neumann boundary conditions:\nimport updes\nimport jax.numpy as jnp\n\n# Create a mesh-free cloud of points on a unit square\nfacet_types={\"South\":\"n\", \"West\":\"d\", \"North\":\"d\", \"East\":\"d\"}\ncloud = updes.SquareCloud(Nx=30, Ny=20, facet_types=facet_types)\n\n# Define the differential operator (left-hand side of the PDE)\ndef my_diff_operator(x, center, rbf, monomial, fields):\n    return updes.nodal_laplacian(x, center, rbf, monomial)\n\n# Define the right-hand side of the PDE\ndef my_rhs_operator(x, centers, rbf, fields):\n    return 0.0\n\n# Set a sin function as the Dirichlet BC on the North, and zero everywhere else\nsine = lambda coord: jnp.sin(jnp.pi * coord[0])\nzero = lambda coord: 0.0\nboundary_conditions = {\"South\":zero, \"West\":zero, \"North\":sine, \"East\":zero}\n\n# Solve the Laplace equation with a JIT-compiled solver\nsol = updes.pde_solver_jit(diff_operator=my_diff_operator, \n                    rhs_operator=my_rhs_operator, \n                    cloud=cloud, \n                    boundary_conditions=boundary_conditions, \n                    rbf=updes.polyharmonic,\n                    max_degree=1)\n\n# Visualize the solution\ncloud.visualize_field(sol.vals, cmap=\"jet\", projection=\"3d\", title=\"RBF solution\")\nùïåpdes can handle much complicated cases with little to no modifications to the code above. Check out further notebooks and scripts in the documentation and the folder demos!\n\n\n\n\nCore: JAX - GMSH - Matplotlib - Seaborn - Scikit-Learn\nOptional: PyVista - FFMPEG - QuartoDoc\n\nSee the pyproject.toml file the specific versions of the dependencies.\n\n\n\nIf you use this software, please cite us with the following BibTeX entry:\n@inproceedings{nzoyem2023comparison,\n  title={A comparison of mesh-free differentiable programming and data-driven strategies for optimal control under PDE constraints},\n  author={Nzoyem Ngueguin, Roussel Desmond and Barton, David AW and Deakin, Tom},\n  booktitle={Proceedings of the SC'23 Workshops of The International Conference on High Performance Computing, Network, Storage, and Analysis},\n  pages={21--28},\n  year={2023}}"
  },
  {
    "objectID": "assets/README_PyPI.html#features",
    "href": "assets/README_PyPI.html#features",
    "title": "ùïåpdes",
    "section": "",
    "text": "ùïåpdes leverages Radial Basis Functions (RBFs) and JAX to provide the following features: - User-centric design: no need to re-implement a solver for each new PDE - Lightning fast mesh-free simulation via Radial Basis Functions - Robust differentiable simulation via JAX, and portable across CPU, GPU, and TPU - Support for Dirichlet, Neumann, Robin, and Periodic boundary conditions - Automatic generation of normals from 2D GMSH meshes\nùïåpdes in incredibly extendable, with additional features added frequently."
  },
  {
    "objectID": "assets/README_PyPI.html#getting-started",
    "href": "assets/README_PyPI.html#getting-started",
    "title": "ùïåpdes",
    "section": "",
    "text": "The package is available on PyPI. You can install it with\npip install updes\nThe example below illustrates how to solve the Laplace equation with Dirichlet and Neumann boundary conditions:\nimport updes\nimport jax.numpy as jnp\n\n# Create a mesh-free cloud of points on a unit square\nfacet_types={\"South\":\"n\", \"West\":\"d\", \"North\":\"d\", \"East\":\"d\"}\ncloud = updes.SquareCloud(Nx=30, Ny=20, facet_types=facet_types)\n\n# Define the differential operator (left-hand side of the PDE)\ndef my_diff_operator(x, center, rbf, monomial, fields):\n    return updes.nodal_laplacian(x, center, rbf, monomial)\n\n# Define the right-hand side of the PDE\ndef my_rhs_operator(x, centers, rbf, fields):\n    return 0.0\n\n# Set a sin function as the Dirichlet BC on the North, and zero everywhere else\nsine = lambda coord: jnp.sin(jnp.pi * coord[0])\nzero = lambda coord: 0.0\nboundary_conditions = {\"South\":zero, \"West\":zero, \"North\":sine, \"East\":zero}\n\n# Solve the Laplace equation with a JIT-compiled solver\nsol = updes.pde_solver_jit(diff_operator=my_diff_operator, \n                    rhs_operator=my_rhs_operator, \n                    cloud=cloud, \n                    boundary_conditions=boundary_conditions, \n                    rbf=updes.polyharmonic,\n                    max_degree=1)\n\n# Visualize the solution\ncloud.visualize_field(sol.vals, cmap=\"jet\", projection=\"3d\", title=\"RBF solution\")\nùïåpdes can handle much complicated cases with little to no modifications to the code above. Check out further notebooks and scripts in the documentation and the folder demos!"
  },
  {
    "objectID": "assets/README_PyPI.html#dependencies",
    "href": "assets/README_PyPI.html#dependencies",
    "title": "ùïåpdes",
    "section": "",
    "text": "Core: JAX - GMSH - Matplotlib - Seaborn - Scikit-Learn\nOptional: PyVista - FFMPEG - QuartoDoc\n\nSee the pyproject.toml file the specific versions of the dependencies."
  },
  {
    "objectID": "assets/README_PyPI.html#cite-us",
    "href": "assets/README_PyPI.html#cite-us",
    "title": "ùïåpdes",
    "section": "",
    "text": "If you use this software, please cite us with the following BibTeX entry:\n@inproceedings{nzoyem2023comparison,\n  title={A comparison of mesh-free differentiable programming and data-driven strategies for optimal control under PDE constraints},\n  author={Nzoyem Ngueguin, Roussel Desmond and Barton, David AW and Deakin, Tom},\n  booktitle={Proceedings of the SC'23 Workshops of The International Conference on High Performance Computing, Network, Storage, and Analysis},\n  pages={21--28},\n  year={2023}}"
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "In this tutorial, we will simulate a Advection-Diffusion equation in 2D using Updes."
  },
  {
    "objectID": "examples.html#step-1-installation",
    "href": "examples.html#step-1-installation",
    "title": "Examples",
    "section": "Step 1: Installation",
    "text": "Step 1: Installation\nBefore we begin, let‚Äôs ensure we have the necessary package installed. Run the following command to install the updes package:\n# Install the updes package\n!pip install updes"
  },
  {
    "objectID": "examples.html#step-2-introduction",
    "href": "examples.html#step-2-introduction",
    "title": "Examples",
    "section": "Step 2: Introduction",
    "text": "Step 2: Introduction\nIn this step, we‚Äôll introduce the concept of the advection-diffusion equation and set up the parameters required for the simulation.\nThe advection-diffusion equation describes the transport (advection) of a quantity \\(u(x,y,t)\\), such as heat or fluid concentration while it is diffused in the medium. Mathematically, the advection-diffusion equation defined in a domain \\(\\Omega\\) can be written as: \\[\n\\frac{\\partial u}{ \\partial t} + \\nabla \\cdot (u \\mathbf{v}) = k \\nabla^2 u\n\\] where:\n\n\\(u\\) is the quantity being transported,\n\\(t\\) is time,\n\\(\\mathbf{v}\\) is the velocity vector,\n\\(k\\) is the diffusive constant, and\n\\(\\nabla^2\\) is the Laplacian operator.\n\nLet the domain be a unit square. The PDE above is complemented by periodic boundary conditions in both directions, i.e.,\n\n\\(u(x, 0, t) = u(x, 1, t)\\) and\n\\(u(0, y, t) = u(1, y, t)\\).\n\nAdditionally, we enforce their normal derivatives to be equal to each other:\n\n\\(\\frac{\\partial u}{\\partial x}(x, 0, t) = \\frac{\\partial u}{\\partial x}(x, 1, t)\\) and\n\\(\\frac{\\partial u}{\\partial y}(0, y, t) = \\frac{\\partial u}{\\partial y}(1, y, t)\\).\n\nNow, let‚Äôs import necessary packages and set up the parameters for our simulation:\n# Import necessary packages\nimport jax\nimport jax.numpy as jnp\nfrom updes import *\n\n# Parameters\nDT = 1e-4             # Time step size\nNB_TIMESTEPS = 100    # Number of time steps\nPLOT_EVERY = 10       # Plot every nth time step\nK = 0.08              # Diffusive constant\nVEL = jnp.array([100.0, 0.0])  # Velocity vector\nNx = 25               # Number of grid points in x-direction\nNy = 25               # Number of grid points in y-direction"
  },
  {
    "objectID": "examples.html#step-3-creating-a-square-cloud-and-defining-initial-condition",
    "href": "examples.html#step-3-creating-a-square-cloud-and-defining-initial-condition",
    "title": "Examples",
    "section": "Step 3: Creating a Square Cloud and Defining Initial Condition",
    "text": "Step 3: Creating a Square Cloud and Defining Initial Condition\nNow, we‚Äôll create a square computational domain and define the initial condition for the quantity being transported. Unlike Neumann n, Dirichlet d, or Robin r boundary conditions, the periodic boundary p* needs a special treatment. We must provide a common identifier for boundaries (or more generally, facets) on which the quantity \\(u\\) doesn‚Äôt change, i.e., p1 for the South and North facets and p2 for the West and East facets.\n# Creating a square cloud\nfacet_types = {\"South\": \"p1\", \"North\": \"p1\", \"West\": \"p2\", \"East\": \"p2\"}\ncloud = SquareCloud(Nx=Nx, Ny=Ny, facet_types=facet_types)\nThe SquareCloud class can take arguments to scatter its nodes. It inherits from the Cloud class, which is a base class for all clouds in Updes, including clouds built from GMSH meshes. All Cloud instances provide methods to visualize the computational domain, its normals, and the solution. See the API for more on the Cloud class.\nThe computational domain is discretized into a grid of points surgically sorted based on the boundary type of the facet they belong to. We will used those sorted_nodes to define the initial condition which specifies the initial distribution of the quantity \\(u\\). Here, we‚Äôll use a Gaussian signal:\n\\[\nu(x, y, 0) = \\exp\\left(-\\frac{(x - 0.35)^2 + (y - 0.5)^2}{0.1}\\right)\n\\]\n# Defining the initial condition using a Gaussian distribution\ndef gaussian(x, y, x0, y0, sigma):\n    return jnp.exp(-((x-x0)**2 + (y-y0)**2) / (2*sigma**2))\n\nxy = cloud.sorted_nodes\nu0 = gaussian(xy[:,0], xy[:,1], 0.35, 0.5, 1/10)"
  },
  {
    "objectID": "examples.html#step-4-defining-differential-and-right-hand-side-operators",
    "href": "examples.html#step-4-defining-differential-and-right-hand-side-operators",
    "title": "Examples",
    "section": "Step 4: Defining Differential and Right-hand Side Operators",
    "text": "Step 4: Defining Differential and Right-hand Side Operators\nFor that, we discretize the problem along the time direction using a Backward Euler scheme. No need to discretize the problem along the spatial direction as Updes does it for you. The PDE becomes: \\[\n\\frac{u^{n+1} - u^n}{\\Delta t} + \\nabla \\cdot (u^{n+1} \\mathbf{v}) = k \\nabla^2 u^{n+1}\n\\]\nWe can now isolate to define the differential and the right-hand side operators for the advection-diffusion equation for this implicit scheme to solve for \\(u^{n+1}\\) at each time step:\n\\[\n\\frac{u^{n+1}}{\\Delta t} + \\nabla \\cdot (u^{n+1} \\mathbf{v}) - k \\nabla^2 u^{n+1} =  \\frac{u^n}{\\Delta t}\n\\]\ndef my_diff_operator(x, center=None, rbf=None, monomial=None, fields=None):\n    val = nodal_value(x, center, rbf, monomial)\n    grad = nodal_gradient(x, center, rbf, monomial)\n    lap = nodal_laplacian(x, center, rbf, monomial)\n    return (val/DT) + jnp.dot(VEL, grad) - K*lap\n\ndef my_rhs_operator(x, centers=None, rbf=None, fields=None):\n    return value(x, fields[:,0], centers, rbf) / DT\nThe signature of these two operators is paramounts, as defined in the API section for Operators\nNote that in our custom differential operator, we used the nodal_value, nodal_gradient, and nodal_laplacian functions to compute the value, gradient, and Laplacian of the quantity \\(u\\) at the nodes, respectively. The nodal indicates that these values are tied to the center of the RBF when those functions are used. However, in our RHS operator, all centers are used, and thus the RBF is applied with respect to all nodes.\nAlso, our custom operators all take extra fiels as argument, these are known quantities that are passed to the operators via the PDE solver below."
  },
  {
    "objectID": "examples.html#step-5-setting-boundary-conditions",
    "href": "examples.html#step-5-setting-boundary-conditions",
    "title": "Examples",
    "section": "Step 5: Setting Boundary Conditions",
    "text": "Step 5: Setting Boundary Conditions\nUpdes needs a dictionary with the same keys as facet_types and values as the boundary conditions. Here, we will use the periodic boundary conditions for all facets. Since we are enforcing equality in periodic boundary conditions, we can use a lambda function that returns zero for all boundaries.\nd_zero = lambda x: 0.\nboundary_conditions = {\"South\": d_zero, \"West\": d_zero, \"North\": d_zero, \"East\": d_zero}"
  },
  {
    "objectID": "examples.html#step-6-solving-the-advection-diffusion-equation",
    "href": "examples.html#step-6-solving-the-advection-diffusion-equation",
    "title": "Examples",
    "section": "Step 6: Solving the Advection-Diffusion Equation",
    "text": "Step 6: Solving the Advection-Diffusion Equation\nNow that we have our operators defined and boundary conditions set, we‚Äôre ready to solve the advection-diffusion equation over time.\nWe‚Äôll use a time-stepping approach to numerically integrate the equation forward in time. At each time step, we‚Äôll apply the differential operator to compute the next state of the system.\nu = u0\nulist = [u]\n\nfor i in range(1, NB_TIMESTEPS+1):\n    ufield = pde_solver_jit(diff_operator=my_diff_operator,\n                             rhs_operator=my_rhs_operator,\n                             rhs_args=[u],\n                             cloud=cloud,\n                             boundary_conditions=boundary_conditions,\n                             max_degree=0)\n\n    u = ufield.vals\n    ulist.append(u)\n\n    if i &lt;= 3 or i % PLOT_EVERY == 0:\n        print(f\"Step {i}\")\n        ax, _ = cloud.visualize_field(u, cmap=\"jet\", title=f\"Step {i}\", vmin=0, vmax=1, figsize=(6,3),colorbar=False)\n        plt.show()\nThe cornerstone of Updes is the pde_solver function. It takes the differential and right-hand side operators, the cloud, the boundary conditions, and the maximum degree of the polynomial to be added to our RBF approximation. The rhs_args argument is a list of known quantities that are passed to the right-hand side operator (we could have equally used diff_args if there was such a need). The pde_solver function returns a Field object that contains the solution at all the points in the domain. Note that we use the pde_solver_jit to directly leverage jax.jit‚Äôs compilation for faster (re)execution of this function."
  },
  {
    "objectID": "examples.html#step-7-visualization",
    "href": "examples.html#step-7-visualization",
    "title": "Examples",
    "section": "Step 7: Visualization",
    "text": "Step 7: Visualization\nAfter simulating the advection-diffusion equation and obtaining the results, it‚Äôs crucial to visualize the evolution of the quantity of interest over time. Visualization helps us understand the behavior of the system and interpret the simulation outcomes.\ncloud.animate_fields([ulist], \n                    cmaps=\"jet\", \n                    filename=\"adv_dif.gif\", \n                    figsize=(7,5.3),\n                    titles=[\"Advection-Diffusion with RBFs\"]);\nAgain, the cloud class provides a method to animate the collected fields over time. The animate_fields method takes a list of fields‚Äôs trajectories to animate, the colormap to use, the filename to save the animation, the figure size, and the titles of the frames, and many others. The resulting simulation can be seen below:\n\n\n\nAdvection-Diffusion with Radial Basis Functions (RBFs) and the Updes differentiable simulator.\n\n\nNOTE: For a more complete version of this script, see the GitHub repository here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ùïåpdes",
    "section": "",
    "text": "ùïåpdes is a general-purpose library for mesh-free PDE simulation and control.\nIt supports:\n\nUser-centric design: no need to re-implement a solver for each new PDE\nLightning fast mesh-free simulation via Radial Basis Functions\nRobust differentiable simulation via JAX, and portable across CPU, GPU, and TPU\nSupport for Dirichlet, Neumann, Robin, and Periodic boundary conditions\nAutomatic generation of normals from 2D GMSH meshes\nùïåpdes in incredibly extendable, with additional features added frequently.\nMany more to come‚Ä¶\n\nTo get started using this library:\n\nInstall the package with: pip install updes.\nFollow the tutorials from Examples.\nGo further by reading the API.\n\nWe welcome contributions in all areas above. Please feel free to open up an issue or a pull request if anything is unclear üôÇ."
  },
  {
    "objectID": "reference/operators.gradient.html",
    "href": "reference/operators.gradient.html",
    "title": "operators.gradient",
    "section": "",
    "text": "operators.gradient\noperators.gradient(x, field, centers, rbf=None, clip_val=None)\nComputes the gradient of the field (given by its coefficients) at position x\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The position at which to conmpute the gradient value centers (Float[Array, ‚Äúnb_centers, dim‚Äù]): The centroids of the RBF to use rbf (callable): The rbf to use. (Currently mandadatory, despite the signature.) clip_val (float, optional): The limit to which to clip the value to avoid blowup. Defaults to None.\nReturns: Float[Array, ‚Äúdim‚Äù]: The gradient of the field at x"
  },
  {
    "objectID": "reference/assembly.compute_coefficients.html",
    "href": "reference/assembly.compute_coefficients.html",
    "title": "assembly.compute_coefficients",
    "section": "",
    "text": "assembly.compute_coefficients\nassembly.compute_coefficients(field, cloud, rbf, max_degree)\nFind nodal and polynomial coefficients for scalar field"
  },
  {
    "objectID": "reference/utils.compute_nb_monomials.html",
    "href": "reference/utils.compute_nb_monomials.html",
    "title": "utils.compute_nb_monomials",
    "section": "",
    "text": "utils.compute_nb_monomials\nutils.compute_nb_monomials(max_degree, problem_dimension)\nComputes the number of monomials of dregree less than ‚Äòmax_degree‚Äô, in dimension ‚Äòproblem_dimension‚Äô"
  },
  {
    "objectID": "reference/operators.nodal_div_grad.html",
    "href": "reference/operators.nodal_div_grad.html",
    "title": "operators.nodal_div_grad",
    "section": "",
    "text": "operators.nodal_div_grad\noperators.nodal_div_grad(x, center=None, rbf=None, monomial=None, args=None)\nComputes the laplacian as the divergence of the gradient of the rbf or polynomial at position x\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The position at which to evaluate the laplacian rbf or polynomial center (Float[Array, ‚Äúdim‚Äù]): The centroid of the RBF if used. (Currently mandadatory, despite the signature.) rbf (callable): The rbf to use. (Currently mandadatory, despite the signature.) monomial (callable): The monomial to use. (Currently mandadatory, despite the signature.)\nReturns: float: The value of the laplacian rbf or polynomial at x"
  },
  {
    "objectID": "reference/assembly.assemble_B.html",
    "href": "reference/assembly.assemble_B.html",
    "title": "assembly.assemble_B",
    "section": "",
    "text": "assembly.assemble_B\nassembly.assemble_B(operator, cloud, rbf, nb_monomials, diff_args, robin_coeffs)\nAssemble matrix B using opPhi, bdPhi, opP, bdP, and A, see equation (*) from Shahane et al.\nArgs: operator (callable): the differential operator to apply cloud (Cloud): the cloud of points to use rbf (callable): the radial basis function to use nb_monomials (int): the number of monomials to use diff_args (list): the fields to use in the aplication of the operator. Can be either the field values themselves or their coefficients robin_coeffs (dict): the coefficients for the Robin boundary conditions if needed\nReturns: Float[Array, ‚Äúdim1 nb_nodes‚Äù]: The matrix B to use in the PDE solver"
  },
  {
    "objectID": "reference/utils.thin_plate.html",
    "href": "reference/utils.thin_plate.html",
    "title": "utils.thin_plate",
    "section": "",
    "text": "utils.thin_plate\nutils.thin_plate(x, center, a=1)\nThin Plate Spline RBF"
  },
  {
    "objectID": "reference/assembly.assemble_P.html",
    "href": "reference/assembly.assemble_P.html",
    "title": "assembly.assemble_P",
    "section": "",
    "text": "assembly.assemble_P\nassembly.assemble_P(cloud, nb_monomials)\nAssemble the polynomial matrix P (see equation 6 from Shahane et al.)\nArgs: cloud (Cloud): The cloud of points to use, along with all required information nb_monomials (int): The number of monomials to use, with increasing degree\nReturns: Float[Array, ‚Äúnb_nodes, nb_monomials‚Äù]: The matrix P"
  },
  {
    "objectID": "reference/assembly.assemble_bd_Phi_P.html",
    "href": "reference/assembly.assemble_bd_Phi_P.html",
    "title": "assembly.assemble_bd_Phi_P",
    "section": "",
    "text": "assembly.assemble_bd_Phi_P\nassembly.assemble_bd_Phi_P(cloud, rbf, nb_monomials, robin_coeffs=None)\nAssembles bd(Phi) and bd(P), the collocation and polynomial matrices after boundary conditions are applied to boundary nodes\nArgs: cloud (Cloud): the cloud of points to use rbf (callable): the radial basis function to use nb_monomials (int): the number of monomials to use robin_coeffs (dict): the coefficients for the Robin boundary conditions if needed\nReturns: tuple(Float[Array, ‚Äúnb_boundary_nodes nb_nodes‚Äù], Float[Array, ‚Äúnb_boundary_nodes nb_monomials‚Äù]): The boundary operator matrices"
  },
  {
    "objectID": "reference/utils.make_all_monomials.html",
    "href": "reference/utils.make_all_monomials.html",
    "title": "utils.make_all_monomials",
    "section": "",
    "text": "utils.make_all_monomials\nutils.make_all_monomials(nb_monomials)\nA function that returns up to a certain number of monomials"
  },
  {
    "objectID": "reference/operators.apply_neumann_conditions.html",
    "href": "reference/operators.apply_neumann_conditions.html",
    "title": "operators.apply_neumann_conditions",
    "section": "",
    "text": "operators.apply_neumann_conditions\noperators.apply_neumann_conditions(field, boundary_conditions, cloud)\nEnforces the Neumann boundary conditions to the field"
  },
  {
    "objectID": "reference/cloud.SquareCloud.html",
    "href": "reference/cloud.SquareCloud.html",
    "title": "cloud.SquareCloud",
    "section": "",
    "text": "cloud.SquareCloud(self, Nx=7, Ny=5, noise_key=None, **kwargs)\nA class to store a cloud of (scattered or regular) points on a unit square\n\n\n\n\n\nName\nDescription\n\n\n\n\ndefine_global_indices\nDefines the 2d coordinates to 1d indices map and vice-versa\n\n\ndefine_node_coordinates\nCalculates the coordinates of the nodes in the square domain. Optionally adds noise to the coordinates\n\n\ndefine_node_types\nDefines the boundary dype for each node in the square domain\n\n\ndefine_outward_normals\nMakes the outward normal vectors to nodes on the boundaries\n\n\n\n\n\ncloud.SquareCloud.define_global_indices()\nDefines the 2d coordinates to 1d indices map and vice-versa\n\n\n\ncloud.SquareCloud.define_node_coordinates(noise_key)\nCalculates the coordinates of the nodes in the square domain. Optionally adds noise to the coordinates\n\n\n\ncloud.SquareCloud.define_node_types()\nDefines the boundary dype for each node in the square domain\n\n\n\ncloud.SquareCloud.define_outward_normals()\nMakes the outward normal vectors to nodes on the boundaries"
  },
  {
    "objectID": "reference/cloud.SquareCloud.html#methods",
    "href": "reference/cloud.SquareCloud.html#methods",
    "title": "cloud.SquareCloud",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndefine_global_indices\nDefines the 2d coordinates to 1d indices map and vice-versa\n\n\ndefine_node_coordinates\nCalculates the coordinates of the nodes in the square domain. Optionally adds noise to the coordinates\n\n\ndefine_node_types\nDefines the boundary dype for each node in the square domain\n\n\ndefine_outward_normals\nMakes the outward normal vectors to nodes on the boundaries\n\n\n\n\n\ncloud.SquareCloud.define_global_indices()\nDefines the 2d coordinates to 1d indices map and vice-versa\n\n\n\ncloud.SquareCloud.define_node_coordinates(noise_key)\nCalculates the coordinates of the nodes in the square domain. Optionally adds noise to the coordinates\n\n\n\ncloud.SquareCloud.define_node_types()\nDefines the boundary dype for each node in the square domain\n\n\n\ncloud.SquareCloud.define_outward_normals()\nMakes the outward normal vectors to nodes on the boundaries"
  },
  {
    "objectID": "reference/operators.nodal_laplacian.html",
    "href": "reference/operators.nodal_laplacian.html",
    "title": "operators.nodal_laplacian",
    "section": "",
    "text": "operators.nodal_laplacian\noperators.nodal_laplacian(x, center=None, rbf=None, monomial=None)\nComputes the laplacian as the trace of the jacobian of the gradient of the rbf or polynomial at position x\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The position at which to evaluate the laplacian rbf or polynomial center (Float[Array, ‚Äúdim‚Äù]): The centroid of the RBF if used. (Currently mandadatory, despite the signature.) rbf (callable): The rbf to use. (Currently mandadatory, despite the signature.) monomial (callable): The monomial to use. (Currently mandadatory, despite the signature.)\nReturns: float: The value of the laplacian rbf or polynomial at x"
  },
  {
    "objectID": "reference/assembly.assemble_op_Phi_P.html",
    "href": "reference/assembly.assemble_op_Phi_P.html",
    "title": "assembly.assemble_op_Phi_P",
    "section": "",
    "text": "assembly.assemble_op_Phi_P\nassembly.assemble_op_Phi_P(operator, cloud, rbf, nb_monomials, args)\nAssembles op(Phi) and op(P), the collocation and polynomial matrices after a differential operator is applied to internal nodes\nArgs: operator (callable): the differential operator to apply cloud (Cloud): the cloud of points to use rbf (callable): the radial basis function to use nb_monomials (int): the number of monomials to use args (list): the fields to use in the aplication of the operator. Can be either the field values themselves or their coefficients\nReturns: tuple(Float[Array, ‚Äúnb_internal_nodes nb_nodes‚Äù], Float[Array, ‚Äúnb_internal_nodes nb_monomials‚Äù]): The internal operator matrices"
  },
  {
    "objectID": "reference/operators.duplicate_robin_coeffs.html",
    "href": "reference/operators.duplicate_robin_coeffs.html",
    "title": "operators.duplicate_robin_coeffs",
    "section": "",
    "text": "operators.duplicate_robin_coeffs\noperators.duplicate_robin_coeffs(boundary_conditions, cloud)\nDuplicate the Robin coefficients to the nodes of the facets they are applied to"
  },
  {
    "objectID": "reference/utils.gaussian.html",
    "href": "reference/utils.gaussian.html",
    "title": "utils.gaussian",
    "section": "",
    "text": "utils.gaussian\nutils.gaussian(x, center, eps=1.0)\nGaussian RBF"
  },
  {
    "objectID": "reference/operators.value.html",
    "href": "reference/operators.value.html",
    "title": "operators.value",
    "section": "",
    "text": "operators.value\noperators.value(x, field, centers, rbf=None, clip_val=None)\nComputes the value of the field (given by its coefficients) at position x\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The position at which to conmpute the field value centers (Float[Array, ‚Äúnb_centers, dim‚Äù]): The centroids of the RBF to use rbf (callable): The rbf to use. (Currently mandadatory, despite the signature.) clip_val (float, optional): The limit to which to clip the value to avoid blowup. Defaults to None.\nReturns: float: The value of the field at x"
  },
  {
    "objectID": "reference/operators.pde_solver.html",
    "href": "reference/operators.pde_solver.html",
    "title": "operators.pde_solver",
    "section": "",
    "text": "operators.pde_solver\noperators.pde_solver(diff_operator, rhs_operator, cloud, boundary_conditions, rbf, max_degree, diff_args=None, rhs_args=None)\nSolves a PDE using radial basis functions\nArgs: diff_operator (callable): The differential operator (the left-hand side of the PDE), evaluated at each internal point with respect to each RBF centroid seperately, i.e.¬†nodal evaluation. rhs_operator (callable): The right-hand-side operator, evaluated at each node with respect to all centroids at once, i.e.¬†global evaluation. cloud (Cloud): The cloud on which to solve the PDE boundary_conditions (dict): The boundary conditions to enforce, one for each facet given by an approiate vector rbf (callable): The radial basis function to use max_degree (int): The maximum degree of the polynomial to use in the RBF diff_args (list, optional): The arguments to pass to the differential operator. Defaults to None. rhs_args (list, optional): The arguments to pass to the right-hand-side operator. Defaults to None.\nReturns: SteadySol: A named tuple containing the values and coefficients of the solution, as well as the matrix used in the linear solve"
  },
  {
    "objectID": "reference/utils.distance.html",
    "href": "reference/utils.distance.html",
    "title": "utils.distance",
    "section": "",
    "text": "utils.distance\nutils.distance(node1, node2)\nEuclidean distance between two points."
  },
  {
    "objectID": "reference/utils.plot.html",
    "href": "reference/utils.plot.html",
    "title": "utils.plot",
    "section": "",
    "text": "utils.plot\nutils.plot(*args, ax=None, figsize=(6, 3.5), x_label=None, y_label=None, title=None, x_scale='linear', y_scale='linear', xlim=None, ylim=None, **kwargs)\nWrapper function for matplotlib and seaborn"
  },
  {
    "objectID": "reference/utils.RK4.html",
    "href": "reference/utils.RK4.html",
    "title": "utils.RK4",
    "section": "",
    "text": "utils.RK4\nutils.RK4(fun, t_span, y0, *args, t_eval=None, subdivisions=1, **kwargs)\nNumerical integration with RK4 and fixed-time stepping, but with fine subdivisions of the evaluation time intervals\nArgs: fun (Callable): The function to be integrated. y0 (Float[Array]): The initial condition. t_span (Tuple): The time interval for which the integration is to be performed. t_eval (Float[Array]): The time points at which the solution is to be evaluated. subdivisions (int): To improve stability, each interval in t_eval is divided into this many subdivisions. Consider increasing this if you obtain NaNs. *args: Additional arguments to be passed to the function. **kwargs: Additional keyword arguments to be passed to the function.\nRaises: Warning: if t_span[0] is None. ValueError: if t_eval is None and t_span[1] is None.\nReturns: Float[Array, ‚Äúnb_time_steps‚Äù]: The solution at the time points in t_eval."
  },
  {
    "objectID": "reference/utils.make_monomial.html",
    "href": "reference/utils.make_monomial.html",
    "title": "utils.make_monomial",
    "section": "",
    "text": "utils.make_monomial\nutils.make_monomial(x, id)\nA function that returns the value of a monomial at a given point x.\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The point at which the monomial is to be evaluated. id (int): The id of the monomial to be evaluated.\nReturns: float: The value of the monomial at the given point x."
  },
  {
    "objectID": "reference/assembly.get_field_coefficients.html",
    "href": "reference/assembly.get_field_coefficients.html",
    "title": "assembly.get_field_coefficients",
    "section": "",
    "text": "assembly.get_field_coefficients\nassembly.get_field_coefficients(field, cloud, rbf, max_degree)\nFind nodal and polynomial coefficients for scalar field. Alias of compute_coefficients()"
  },
  {
    "objectID": "reference/operators.nodal_gradient.html",
    "href": "reference/operators.nodal_gradient.html",
    "title": "operators.nodal_gradient",
    "section": "",
    "text": "operators.nodal_gradient\noperators.nodal_gradient(x, center=None, rbf=None, monomial=None)\nComputes the gradient of the rbf or polynomial at position x\nArgs: x (Float[Array, ‚Äúdim‚Äù]): The position at which to evaluate the gradient rbf or polynomial center (Float[Array, ‚Äúdim‚Äù]): The centroid of the RBF if used. (Currently mandadatory, despite the signature.) rbf (callable): The rbf to use. (Currently mandadatory, despite the signature.) monomial (callable): The monomial to use. (Currently mandadatory, despite the signature.)\nReturns: Float[Array, ‚Äúdim‚Äù]: The value of the gradient rbf or polynomial at x"
  },
  {
    "objectID": "reference/operators.zerofy_periodic_cond.html",
    "href": "reference/operators.zerofy_periodic_cond.html",
    "title": "operators.zerofy_periodic_cond",
    "section": "",
    "text": "operators.zerofy_periodic_cond\noperators.zerofy_periodic_cond(boundary_conditions, cloud)\nZero out the periodic boundary conditions (this is aplied before the PDE solve, to overwrite any value set by the user)"
  }
]